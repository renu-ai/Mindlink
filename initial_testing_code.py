# -*- coding: utf-8 -*-
"""CIS7000_Final_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oisAQw8uOYSeIkqEklNMn7lis7qtowu_

**1. Setup and API Configuration**
"""

!pip install --upgrade openai

!pip show openai

from google.colab import userdata
import openai
import os
from openai import OpenAI

# setup OpenAI API Key
os.environ['OPENAI_API_KEY'] = userdata.get('OpenAI_api_key')
openai_api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=openai_api_key)

# ChatGPT API Wrapper
def generate_chatgpt_response(prompt: str) -> str:
    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",  # GPT model
            messages=[{"role": "user", "content": prompt}],  # user input as messages
            max_tokens=300,  # desired response length
            temperature=0.7  # creativity
        )
        message = response.choices[0].message.content.strip()
        return message
    except openai.OpenAIError as e:
        return f"Error in ChatGPT API: {str(e)}"

# memory buffer to store user-provided context
conversation_memory = []

# function to update memory with key details
def update_memory(user_message: str, memory: list):
    """
    Extract key details from user messages and store them in memory.
    Limits memory to the last 5 entries for brevity.
    """
    # extract key info
    if "event" in user_message.lower():
        memory.append(user_message)

    # keep memory size manageable
    if len(memory) > 5:  # limit to 5 most recent entries
        memory.pop(0)

    return memory

# function to inject memory context into conversation
def inject_memory(prompt: str, memory: list):
    """
    Injects relevant memory context into the chatbot prompt.
    """
    if memory:
        memory_context = "Previously, you mentioned: " + "; ".join(memory)
        return f"{memory_context}\n{prompt}"
    else:
        return prompt

# generate ChatGPT response with memory injection
def generate_chatgpt_response_with_memory(prompt: str, user_message: str, memory: list) -> str:
    """
    Generates a chatbot response with memory re-injection logic.
    """
    # update memory with user input
    updated_memory = update_memory(user_message, memory)

    # inject memory into prompt
    full_prompt = inject_memory(prompt, updated_memory)

    # get response from ChatGPT
    response = generate_chatgpt_response(full_prompt)

    return response, updated_memory

# testing Memory Injection
test_user_message = "We had a wonderful family picnic on July 4."
conversation_memory = update_memory(test_user_message, conversation_memory)
test_prompt = "Can you tell me more about what happened?"

response, conversation_memory = generate_chatgpt_response_with_memory(
    prompt=test_prompt,
    user_message=test_user_message,
    memory=conversation_memory
)

print("ChatGPT Response:", response)
print("Updated Memory Buffer:", conversation_memory)

# simulate another turn
test_user_message_2 = "It was sunny, and we had a barbecue with friends."
response, conversation_memory = generate_chatgpt_response_with_memory(
    prompt="What else can you recall about the day?",
    user_message=test_user_message_2,
    memory=conversation_memory
)

print("ChatGPT Response:", response)
print("Updated Memory Buffer:", conversation_memory)

# simple testing
test_prompt = "Can you explain the benefits of memory recall for elderly individuals?"
response = generate_chatgpt_response(test_prompt)
print(response)

"""**2. User Profile and Life Log Management**"""

from typing import Dict, List

# User Profile Class
class UserProfile:
    def __init__(self, user_id: str, name: str):
        self.user_id = user_id
        self.name = name
        self.life_logs = []  # store life log entries (text, image, audio)

    def add_life_log(self, log: Dict):
        """
        Add a life log entry to the user's profile.
        """
        self.life_logs.append(log)

    def get_life_logs(self) -> List[Dict]:
        """
        Retrieve life log entries.
        """
        return self.life_logs

# example User Profile
user_profile = UserProfile(user_id="123", name="John Doe")
user_profile.add_life_log({"event": "family picnic", "date": "July 4, 2023", "image_url": "https://example.com/picnic.jpg"})
user_profile.add_life_log({"event": "beach trip", "date": "August 10, 2023", "image_url": "https://example.com/beach.jpg"})
user_profile.add_life_log({"event": "birthday party", "date": "October 15, 2023", "image_url": "https://example.com/birthday.jpg"})

"""**3. Puzzle Engine with GPT Integration**"""

# Puzzle Template and Engine
class PuzzleTemplate:
    def __init__(self, name: str, prompt_template: str, instruction_template: str, hint_rules: callable):
        self.name = name
        self.prompt_template = prompt_template
        self.instruction_template = instruction_template
        self.hint_rules = hint_rules

    def generate_puzzle(self, user_data: Dict) -> Dict:
        """
        generate puzzle instance using user data and hint rules.
        """
        hints = self.hint_rules(user_data)
        base_prompt = self.prompt_template.format(**user_data)

        # refine ChatGPT prompt for better output
        refined_prompt = (
            f"Generate a memory recall puzzle based on this event: {base_prompt}. "
            "The puzzle should ask the user to recall specific details or experiences. "
            "Keep it concise and engaging."
        )

        # get ChatGPT-enhanced prompt
        enhanced_prompt = generate_chatgpt_response(refined_prompt)

        return {
            "name": self.name,
            "prompt": enhanced_prompt,
            "instructions": self.instruction_template.format(**user_data),
            "hints": hints
        }

class PuzzleEngine:
    def __init__(self):
        self.templates = {}

    def register_template(self, template_name: str, template: PuzzleTemplate):
        """
        register a puzzle template in the engine.
        """
        self.templates[template_name] = template

    def create_puzzle(self, template_name: str, user_data: Dict) -> Dict:
        """
        create puzzle using specific template and user data.
        """
        if template_name in self.templates:
            return self.templates[template_name].generate_puzzle(user_data)
        else:
            raise ValueError(f"Template '{template_name}' not found!")

"""**4. Hint Rules and Dynamic Puzzle Example**"""

# Hint Rule for Memory Recall
def memory_hint_rules(user_data: Dict) -> List[str]:
    """
    generate hints based on user's life logs.
    """
    life_logs = user_data.get("life_logs", [])
    if life_logs:
        return [
            f"Hint: Remember the event '{log.get('event', 'Unknown')}' on {log.get('date', 'Unknown')}"
            for log in life_logs[:3]  # use up to 3 recent logs as hints
        ]
    return ["Hint: Try to recall a recent significant event in your life."]

# register Memory Recall Puzzle Template
memory_recall_template = PuzzleTemplate(
    name="Memory Recall Puzzle",
    prompt_template="Can you recall details about '{event_name}'?",
    instruction_template="Think about '{event_name}' and describe what happened, who was there, and how you felt.",
    hint_rules=memory_hint_rules
)

# init Puzzle Engine
puzzle_engine = PuzzleEngine()
puzzle_engine.register_template("MemoryRecall", memory_recall_template)

# gen Puzzle Instance using User Profile
user_data = {
    "event_name": "family picnic",
    "life_logs": user_profile.get_life_logs()
}

puzzle_instance = puzzle_engine.create_puzzle("MemoryRecall", user_data)

# display Generated Puzzle
print("Generated Puzzle:")
print(f"Name: {puzzle_instance['name']}")
print(f"Prompt: {puzzle_instance['prompt']}")
print(f"Instructions: {puzzle_instance['instructions']}")
print(f"Hints: {puzzle_instance['hints']}")

"""**5. Multimodal Hint System**"""

# Multimodal Hint Class
class MultimodalHint:
    def __init__(self, text: str, image_url: str = None, audio_url: str = None):
        self.text = text
        self.image_url = image_url
        self.audio_url = audio_url

    def display_hint(self):
        """
        display multimodal hint.
        """
        print(f"Hint: {self.text}")
        if self.image_url:
            print(f"Image: {self.image_url}")
        if self.audio_url:
            print(f"Audio: {self.audio_url}")

# example Multimodal Hint
multimodal_hint = MultimodalHint(
    text="Remember your trip to the beach?",
    image_url="https://example.com/beach.jpg",
    audio_url="https://example.com/beach_sound.mp3"
)
multimodal_hint.display_hint()

"""*Sample user interation*"""

import ipywidgets as widgets
from IPython.display import display, clear_output

class PuzzleEngine:
    """Class to handle puzzle creation and checking solutions."""
    def __init__(self):
        self.puzzles = [
            {"prompt": "Recall the event 'family picnic' on July 4, 2023. Who was there?", "answer": ["daughter", "husband", "riley", "dog"]},
            {"prompt": "What was the most memorable moment during your beach trip on August 10, 2023?", "answer": ["sunset", "swimming", "kids", "sandcastle"]},
            {"prompt": "What gift did you receive on your birthday party on October 15, 2023?", "answer": ["ikigai", "book", "watch", "game"]}
        ]

    def get_puzzle(self, index):
        """Retrieve a puzzle based on its index."""
        return self.puzzles[index] if index < len(self.puzzles) else None

    def check_answer(self, puzzle, user_answer):
        """Check if the user's answer contains any of the correct keywords."""
        user_answer_lower = user_answer.lower()
        for correct_answer in puzzle["answer"]:
            if correct_answer in user_answer_lower:
                return True, "Correct! Great memory!"
        #if partial match found, provide encouragement
        for correct_answer in puzzle["answer"]:
            if any(word in user_answer_lower for word in correct_answer.split()):
                return True, "Close enough!You can do this!"
        return False, "Oops, that's not quite right."


class UserProfile:
    """Class to store user profile and interaction history with puzzles."""
    def __init__(self, user_id):
        self.user_id = user_id
        self.interaction_history = []

    def store_interaction(self, prompt, user_answer, is_correct, feedback):
        """Store the question, user's answer, and result in interaction history."""
        self.interaction_history.append({
            'prompt': prompt,
            'user_answer': user_answer,
            'is_correct': is_correct,
            'feedback': feedback
        })

    def display_history(self):
        """Display the user's interaction history."""
        for i, interaction in enumerate(self.interaction_history, 1):
            correctness = "Correct" if interaction['is_correct'] else "Incorrect"
            print(f"Interaction {i}:")
            print(f"  Q: {interaction['prompt']}")
            print(f"  Your Answer: {interaction['user_answer']} - {correctness}")
            print(f"  Feedback: {interaction['feedback']}\n")


puzzle_engine = PuzzleEngine()
user_profile = UserProfile(user_id="user_123")

def ask_question(index):
    puzzle = puzzle_engine.get_puzzle(index)
    if not puzzle:
        print("No more puzzles available.")
        user_profile.display_history()
        return

    print(puzzle["prompt"])

    user_input = widgets.Text(placeholder='Type your answer here...')
    submit_button = widgets.Button(description='Submit')

    def on_submit(b):
        user_answer = user_input.value
        is_correct, feedback = puzzle_engine.check_answer(puzzle, user_answer)
        user_profile.store_interaction(puzzle["prompt"], user_answer, is_correct, feedback)

        clear_output()
        print(feedback, "\n")
        ask_question(index + 1)

    submit_button.on_click(on_submit)
    display(user_input, submit_button)


ask_question(0)